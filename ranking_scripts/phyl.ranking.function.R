
## function for phylogenetic ranking of the couplings

# coups = list of couplings above the threshold selected by cumulative coupling value distribution:
#         1st column is the estimated coupling value, 2nd and 3rd columns coupled SNPs mapped to full length genome, 
#         4th and 5th columns are coupled SNPs mapped to filtered fasta generated by SuperDCA
# BAPS = csv-file containing hierBAPS clusters: 1st column lane ID, second column level 1 hierBAPS cluster
# filt.fasta = filtered fasta file generated by SuperDCA

phyl.ranking <- function(coups, BAPS, filt.fasta){

  # lane IDs
  names.v <- names(filt.fasta)

  # fasta to list, each element of list corresponds to a vector of alleles 
  seq.strings <- list()
  for (i in 1:length(filt.fasta)){
   seq.strings[[i]]=toString(filt.fasta[i])
  }
  theletters <- list()
  for (i in 1:length(seq.strings)){
    temp <- strsplit(seq.strings[[i]],'')
    theletters[[i]] <- temp[[1]]
  }

  # hamming distances
  print("Computing Hamming distances...")
  n <- length(theletters)
  m <- matrix(nrow=n, ncol=n)
  for(i in seq_len(n - 1))
    for(j in seq(i, n))
      m[j, i] <- m[i, j] <- sum(theletters[[i]] != theletters[[j]])

  # initialise new variables
  coups$matching.minor <- NA
  coups$baps1 <- NA
  coups$mean.dist <- NA
  coups$sd.dist <- NA
  coups$mean.dist2 <- NA
  coups$sd.dist2 <- NA
  
  print("Computing ranking criteria for coupling....")

  # loop over each coupling
  for(i in 1:nrow(coups)){
  
    print(i)
  
    # vector of alleles observed at the first locus of coupling i
    snp1 <- sapply(theletters, "[[", coups[i,4])
    # vector of alleles observed at the second locus of coupling i
    snp2 <- sapply(theletters, "[[", coups[i,5])
  
    # minor allele at the first locus
    # (gaps are not taken into account)
    # if locus has three or four allels, take the one with second highest frequency
    if(length(names(table(snp1)[names(table(snp1)) != "N" & names(table(snp1)) != "-" ]))>2){
      minor <- names(sort(table(snp1)[names(table(snp1)) != "N" & names(table(snp1)) != "-" ], decreasing = TRUE))[2]
    } else { 
      minor <- names(which.min(table(snp1)[names(table(snp1)) != "N" & names(table(snp1)) != "-" ]))
    }
  
    # which rows (genomes) have the minor allele?
    minor.rows <- which(snp1 == minor)
  
    # all possible pairs of genomes including minor alleles
    pairs <- t(combn(minor.rows, 2))
    # pick hamming distances for these
    distances <- m[pairs]
  
    # mean and sd of distances
    coups$mean.dist[i] <- mean(distances) 
    coups$sd.dist[i] <- sd(distances)
  
    # minor allele at the second locus
    if(length(names(table(snp2)[names(table(snp2)) != "N" & names(table(snp2)) != "-" ]))>2){
      minor2 <- names(sort(table(snp2)[names(table(snp2)) != "N" & names(table(snp2)) != "-" ], decreasing = TRUE))[2]
    } else { # kaksi alleelia, minor se jolla pienempi frekvenssi
      minor2 <- names(which.min(table(snp2)[names(table(snp2)) != "N" & names(table(snp2)) != "-" ]))
    }
    # which rows (genomes) have the minor allele?
    minor.rows2 <- which(snp2 == minor2)
  
    # distances
    pairs2 <- t(combn(minor.rows2, 2))
    distances2 <- m[pairs2]
  
    coups$mean.dist2[i] <- mean(distances2) 
    coups$sd.dist2[i] <- sd(distances2)
  
    # how many genomes have minor allele simultaneously at first and second locus?
    coups$matching.minor[i] <- 0.5*(length(intersect(minor.rows, minor.rows2))/length(minor.rows)+
                                    length(intersect(minor.rows, minor.rows2))/length(minor.rows2))
  
    # to how many BAPS-clusters the minor allele pairs belong?
    baps.rows <- which(as.vector(BAPS[,1]) %in% names.v[intersect(minor.rows, minor.rows2)] == TRUE)
    # number of unique level 1 baps clusters 
    coups$baps1[i] <- length(unique(BAPS[baps.rows,2]))
  }

  # minimum of two average distances
  coups$min.dist <- NA
  for(i in 1:nrow(coups)){
    coups$min.dist[i] <- min(coups$mean.dist[i], coups$mean.dist2[i])
  }

  # normalize and sum the filtering criteria
  coups$norm.baps <- coups$baps1/max(coups$baps1)
  coups$norm.matching.minor <- coups$matching.minor/max(coups$matching.minor)
  coups$norm.min.dist <- coups$min.dist/max(coups$min.dist)
  coups$sum.crit <- coups$norm.baps + coups$norm.matching.minor + coups$norm.min.dist

  # sort couplings according to the new criteria
  coups.ranked <- coups[order(-coups$sum.crit),]
  # add variable that includes the rank
  coups.ranked$phyl.rank <- c(1:nrow(coups.ranked))

  return(list(coups.ranked = coups.ranked))

}
